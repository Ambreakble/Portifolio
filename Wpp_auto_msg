import os
import time
import subprocess
import sys
import csv
import traceback
import tkinter as tk
from tkinter import messagebox, filedialog
import pandas as pd
from selenium import webdriver
from urllib.parse import quote
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from webdriver_manager.chrome import ChromeDriverManager

# ---------------- CONFIGURAÇÕES ----------------
ARQUIVO_EXCEL = "base.xlsx"
HISTORICO = "historico_envios.csv"
CHROME_USER_DATA_DIR = r"C:\whatsapp_profile"
REMOTE_DEBUGGING_PORT = 9222

opcoes = {
    "1":"Bom dia, quem fala é Pablo, assistente comercial da Master Internet, falo com ?",
    "2":"Boa tarde, quem fala é Pablo, assistente comercial da Master Internet, falo com ?",
    "3":"Bom dia, quem fala é Pablo, assistente comercial da Master Internet, tenho no sistema que seu endereço está errado, poderia me enviar um comprovante para correção?",
    "4":"Boa tarde, quem fala é Pablo, assistente comercial da Master Internet, tenho no sistema que seu endereço está errado, poderia me enviar um comprovante para correção?",
    "5":"Olá! Esta é a Mensagem E (exemplo).",
    "6":"Olá! Esta é a Mensagem F (exemplo)."
}

def garantir_pasta_perfil(path):
    os.makedirs(path, exist_ok=True)

def find_chrome_executable():
    candidates = [
        r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
        os.path.expanduser(r"~\AppData\Local\Google\Chrome\Application\chrome.exe"),
    ]
    for c in candidates:
        if os.path.exists(c):
            return c
    try:
        out = subprocess.check_output(["where", "chrome"], shell=True, universal_newlines=True)
        for line in out.splitlines():
            if line.strip().lower().endswith("chrome.exe"):
                return line.strip()
    except:
        pass
    return None

def start_chrome_debug(chrome_path, profile, port):
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect(("127.0.0.1", port))
        s.close()
        return None  # já está rodando
    except:
        pass
    garantir_pasta_perfil(profile)
    cmd = [
        chrome_path,
        f"--remote-debugging-port={port}",
        f"--user-data-dir={profile}",
        "--no-first-run",
        "--no-default-browser-check",
    ]
    proc = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(2)
    return proc

def conectar_selenium(port):
    options = Options()
    options.add_experimental_option("debuggerAddress", f"127.0.0.1:{port}")
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)
    return driver

def carregar_base(caminho):
    if not os.path.exists(caminho):
        root = tk.Tk()
        root.withdraw()
        f = filedialog.askopenfilename(title="Selecione o arquivo Excel", filetypes=[("Excel", "*.xlsx")])
        if not f:
            raise FileNotFoundError("Arquivo Excel não encontrado.")
        return pd.read_excel(f, dtype=str)
    df = pd.read_excel(caminho, dtype=str)
    df.columns = [c.strip() for c in df.columns]
    return df

def registrar_envio(nome, telefone, numos, opcao, mensagem):
    header = ["timestamp", "numos", "nome_assinante", "telefone", "opcao", "mensagem"]
    existe = os.path.exists(HISTORICO)
    with open(HISTORICO, "a", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        if not existe:
            writer.writerow(header)
        writer.writerow([time.strftime("%Y-%m-%d %H:%M:%S"), numos, nome, telefone, opcao, mensagem])

# ------------------------------------------------------------
# JANELA PRINCIPAL
# ------------------------------------------------------------

class BotApp:
    def __init__(self, driver, df):
        self.driver = driver
        self.df = df
        self.assinante_nome = ""
        self.assinante_tel = ""

        self.janela = tk.Tk()
        self.janela.title("Bot WhatsApp - NUMOS → Mensagem")
        self.janela.geometry("480x550")
        self.janela.resizable(False, False)

        tk.Label(self.janela, text="Digite o NUMOS:", font=("Arial", 14)).pack(pady=10)
        self.entrada_numos = tk.Entry(self.janela, font=("Arial", 14), width=22)
        self.entrada_numos.pack()

        frame_busca = tk.Frame(self.janela)
        frame_busca.pack(pady=10)

        tk.Button(frame_busca, text="Buscar Assinante", font=("Arial", 12),
                  command=self.buscar).pack(side=tk.LEFT, padx=6)
        tk.Button(frame_busca, text="Recarregar Excel", font=("Arial", 12),
                  command=self.recarregar_excel).pack(side=tk.LEFT, padx=6)

        self.label_nome = tk.Label(self.janela, text="", font=("Arial", 14))
        self.label_nome.pack(pady=5)
        self.label_tel = tk.Label(self.janela, text="", font=("Arial", 14))
        self.label_tel.pack(pady=5)

        tk.Label(self.janela, text="Escolha a ação:", font=("Arial", 14, "bold")).pack(pady=8)
        frame_botoes = tk.Frame(self.janela)
        frame_botoes.pack()

        for i in range(1, 7):
            tk.Button(frame_botoes, text=str(i), font=("Arial", 14), width=6,
                      command=lambda x=str(i): self.enviar(x)).grid(row=(i-1)//3, column=(i-1)%3, padx=8, pady=8)

        tk.Label(self.janela, text="Log:", font=("Arial", 12, "bold")).pack(pady=6)
        self.text_log = tk.Text(self.janela, height=8, width=55, state=tk.DISABLED)
        self.text_log.pack(pady=4)

        self.text_log.tag_config("erro", foreground="red")
        self.text_log.tag_config("info", foreground="green")
        self.text_log.tag_config("alerta", foreground="orange")

        self.log("Pronto para uso. Insira o NUMOS.", tag="info")

    def log(self, txt, tag="info"):
        self.text_log.configure(state=tk.NORMAL)
        self.text_log.insert(tk.END, f"{time.strftime('%H:%M:%S')} - {txt}\n", tag)
        self.text_log.configure(state=tk.DISABLED)
        self.text_log.see(tk.END)

    def recarregar_excel(self):
        try:
            self.df = carregar_base(ARQUIVO_EXCEL)
            self.assinante_nome = ""
            self.assinante_tel = ""
            self.label_nome.config(text="")
            self.label_tel.config(text="")
            self.log("Excel recarregado com sucesso.", tag="info")
            messagebox.showinfo("OK", "Excel recarregado com sucesso.")
        except Exception as e:
            self.log(f"Erro ao recarregar Excel: {e}", tag="erro")
            messagebox.showerror("Erro", f"Falha ao recarregar Excel:\n{e}")

    def buscar(self):
        numos = self.entrada_numos.get().strip()
        if numos == "":
            messagebox.showerror("Erro", "Digite um NUMOS.")
            return

        linhas = self.df.loc[self.df["numos"] == numos]
        if linhas.empty:
            self.log(f"NUMOS {numos} não encontrado.", tag="erro")
            messagebox.showerror("Erro", "NUMOS não encontrado.")
            return

        linha = linhas.iloc[0]
        nome = linha.get("nome_assinante", "")
        telefones_raw = linha.get("telefones", "")
        if pd.isna(telefones_raw) or telefones_raw.strip() == "":
            messagebox.showerror("Erro", "Telefone inválido.")
            return

        telefones = [t.strip().replace(" ", "").replace("+", "") for t in telefones_raw.split("/") if t.strip()]
        if len(telefones) == 0:
            messagebox.showerror("Erro", "Nenhum telefone válido encontrado.")
            return

        if len(telefones) > 1:
            selecao = tk.Toplevel(self.janela)
            selecao.title(f"Escolha o telefone de {nome}")
            selecao.geometry("450x450")
            selecao.resizable(False, False)

            tk.Label(selecao, text=f"Selecione o telefone para {nome}:", font=("Arial", 12)).pack(pady=10)
            lista = tk.Listbox(selecao, font=("Arial", 12), height=len(telefones), width=25)
            lista.pack(pady=10)
            for tel in telefones:
                lista.insert(tk.END, tel)

            def escolher():
                try:
                    escolhido = lista.get(tk.ACTIVE)
                except:
                    escolhido = None
                if escolhido:
                    self.assinante_tel = escolhido
                    self.assinante_nome = nome
                    self.label_nome.config(text=f"Nome: {nome}")
                    self.label_tel.config(text=f"Telefone: {escolhido}")
                    self.log(f"Carregado: {nome} ({escolhido})", tag="info")
                    selecao.destroy()
                else:
                    messagebox.showerror("Erro", "Selecione um telefone.")

            tk.Button(selecao, text="Enviar para selecionado", font=("Arial", 12), command=escolher).pack(pady=5)

            def enviar_todos():
                escolha_msg = tk.Toplevel(selecao)
                escolha_msg.title("Escolha a mensagem")
                escolha_msg.geometry("500x500")
                escolha_msg.resizable(False, False)

                tk.Label(escolha_msg, text=f"Escolha a mensagem para {nome}:", font=("Arial", 12)).pack(pady=10)
                opcao_var = tk.StringVar(value="1")

                for key, msg in opcoes.items():
                    tk.Radiobutton(
                        escolha_msg,
                        text=f"{key} - {msg[:50]}{'...' if len(msg)>50 else ''}",
                        variable=opcao_var,
                        value=key,
                        font=("Arial", 11),
                        wraplength=320,
                        justify="left"
                    ).pack(anchor="w", padx=20, pady=2)

                def confirmar_envio():
                    opcao_escolhida = opcao_var.get()
                    for tel in telefones:
                        self.assinante_tel = tel
                        self.assinante_nome = nome
                        self.enviar(opcao_escolhida)
                        time.sleep(2)  # Espera 1 segundo entre cada envio
                    escolha_msg.destroy()
                    selecao.destroy()

                tk.Button(escolha_msg, text="Enviar para todos", font=("Arial", 12), command=confirmar_envio).pack(pady=15)

            tk.Button(selecao, text="Enviar para todos", font=("Arial", 12), command=enviar_todos).pack(pady=5)
            return

        # Apenas um telefone
        telefone = telefones[0]
        self.assinante_nome = nome
        self.assinante_tel = telefone
        self.label_nome.config(text=f"Nome: {nome}")
        self.label_tel.config(text=f"Telefone: {telefone}")
        self.log(f"Carregado: {nome} ({telefone})", tag="info")

    def enviar(self, opcao):
        if not self.assinante_tel:
            messagebox.showerror("Erro", "Busque um assinante primeiro.")
            return

        mensagem_base = opcoes[opcao]
        nome = self.assinante_nome.strip()
        if "?" in mensagem_base:
            mensagem = mensagem_base.replace("?", f" {nome}?")
        else:
            mensagem = f"{mensagem_base} {nome}"

        telefone = self.assinante_tel
        try:
            url = f"https://web.whatsapp.com/send?phone={telefone}&text={quote(mensagem)}"
            self.driver.get(url)
            time.sleep(6)

            caixa = None
            seletores = [
                "//div[@contenteditable='true' and @data-tab='10']",
                "//div[@contenteditable='true' and @data-tab='11']",
                "//div[@contenteditable='true' and @data-tab='12']",
                "//div[@contenteditable='true']",
            ]
            for s in seletores:
                try:
                    caixa = self.driver.find_element(By.XPATH, s)
                    break
                except:
                    continue
            if not caixa:
                raise Exception("Campo de mensagem não localizado!")

            caixa.send_keys(Keys.ENTER)
            registrar_envio(nome, telefone, self.entrada_numos.get().strip(), opcao, mensagem)
            self.log(f"Mensagem enviada para {nome} ({telefone})", tag="info")
        except Exception as e:
            self.log(f"Erro ao enviar: {e}", tag="erro")
            messagebox.showerror("Erro", str(e))

# ------------------------------------------------------------
# INÍCIO
# ------------------------------------------------------------

def main():
    chrome_path = find_chrome_executable()
    if not chrome_path:
        messagebox.showerror("Erro", "Chrome não encontrado.")
        return

    start_chrome_debug(chrome_path, CHROME_USER_DATA_DIR, REMOTE_DEBUGGING_PORT)
    driver = conectar_selenium(REMOTE_DEBUGGING_PORT)
    driver.get("https://web.whatsapp.com")
    time.sleep(8)

    try:
        df = carregar_base(ARQUIVO_EXCEL)
    except Exception as e:
        messagebox.showerror("Erro", f"Falha ao carregar Excel: {e}")
        return

    app = BotApp(driver, df)
    app.janela.mainloop()
    driver.quit()

if __name__ == "__main__":
    main()
